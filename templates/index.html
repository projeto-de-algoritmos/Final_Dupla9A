<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=, initial-scale=1.0">
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css" type="text/css">
    <style>
        .map {
            height: 1000px;
            width: 100%;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js"></script>
</head>

<body>
    <h2>My Map</h2>
    <div id="map" class="map"></div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js"
        integrity="sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=" crossorigin="anonymous"></script>
    <script src="{{ url_for('static', filename='locations.js') }}"></script>
    <script type="text/javascript" charset="utf-8">
        let socket = io();
        socket.on('update', function (data) {
            showRoute(data.ids);
            selectPoints(data.points, locations);
        });
    </script>
    <script>
        let routes = {};
        let iconUrl = 'http://cdn.rawgit.com/openlayers/ol3/master/examples/data/icon.png';
        let vectorSource = new ol.source.Vector();
        let vectorLayer = new ol.layer.Vector({
            source: vectorSource
        });
        let styles = {
            route: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    width: 6, color: [40, 40, 40, 0.8]
                })
            }),
            icon: new ol.style.Style({
                image: new ol.style.Icon({
                    anchor: [0.5, 1],
                    src: iconUrl
                })
            }),
            house: new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 7,
                    fill: new ol.style.Fill({ color: 'black' }),
                    stroke: new ol.style.Stroke({
                        color: [255, 0, 0], width: 2
                    })
                })
            }),
            restaurant: new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 7,
                    fill: new ol.style.Fill({ color: 'black' }),
                    stroke: new ol.style.Stroke({
                        color: [255, 255, 255], width: 2
                    })
                })
            }),
        };
        let map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                }),
                vectorLayer
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([-47.9141, -15.8714]),
                zoom: 13
            })
        });

        function selectPoints(solutionPoints, locations) {
            let filteredPoints = solutionPoints.map((point) => {
                return locations.filter((location) => {
                    return location.id === point
                })[0];
            });
            knapsack(filteredPoints, 30);
        }

        function showRoute(subroutes) {
            for (let i = 0; i < subroutes.length; i++) {
                var route = new ol.format.Polyline({
                    factor: 1e5
                }).readGeometry(routes[subroutes[i]], {
                    dataProjection: 'EPSG:4326',
                    featureProjection: 'EPSG:3857'
                });
                var feature = new ol.Feature({
                    type: 'route',
                    geometry: route
                });
                feature.setStyle(styles.route);
                vectorSource.addFeature(feature);
            }
        }

        function filterLocations(locations, type) {
            return locations.filter((location) => {
                return location.id.charAt(0) === type;
            })
        }

        function drawMarkers(points, style) {
            let coords = points.map((location) => {
                return [location.lng, location.lat]
            });
            for (var i = 0; i < coords.length; i++) {
                coords[i] = ol.proj.fromLonLat(coords[i]);
            }
            var feature = new ol.Feature({
                geometry: new ol.geom.MultiPoint(coords)
            });
            feature.setStyle(style);
            vectorSource.addFeature(feature);
        }

        function assignWeightsAndValues(locations) {
            for (let i = 0; i < locations.length; i++) {
                let weight = Math.floor(Math.random() * 30) + 1;
                let value = Math.floor(Math.random() * 100) + 1;
                locations[i].weight = weight;
                locations[i].value = value;
            }
            console.log(locations);
        }

        async function buildRoutes() {
            let graph = [];
            let baseUrl = "http://router.project-osrm.org/route/v1/driving";

            for (let i = 0; i < locations.length - 1; i++) {
                url = `${baseUrl}/${locations[i].lng},${locations[i].lat};${locations[i + 1].lng},${locations[i + 1].lat}`;
                await fetch(url).then((r) => {
                    return r.json()
                }).then((json) => {
                    graph.push({
                        city1: locations[i].id,
                        city2: locations[i + 1].id,
                        interval: Math.round(json.routes[0].distance)
                    })
                    let routeId = `${locations[i].id}${locations[i + 1].id}`;
                    routes[routeId] = json.routes[0].geometry;
                });
            }
            return graph;
        }

        async function sendGraph() {
            assignWeightsAndValues(locations);
            let houses = filterLocations(locations, 'h');
            let restaurants = filterLocations(locations, 'r');
            drawMarkers(houses, styles.house);
            drawMarkers(restaurants, styles.restaurant);
            graph = await buildRoutes();
            socket.emit('solve', { graph: graph, start: "r1", goal: "h1" });
        }


        function knapsack(inputSet, capacity) {
            console.log(inputSet);
            console.log(capacity);

            let rows = inputSet.length - 1;
            let cols = capacity;

            let table = [];
            for (let i = 0; i <= rows; i++) {
                table[i] = [];
                table[i][0] = 0;
            }
            for (let i = 0; i <= cols; i++) {
                table[0][i] = 0;
            }
            for (let i = 1; i <= rows; i++) {
                for (let w = 1; w <= cols; w++) {
                    if (inputSet[i].weight > w) {
                        table[i][w] = table[i - 1][w];
                    } else {
                        let prevValue = table[i - 1][w];
                        let newValue = inputSet[i].value + table[i - 1][w - inputSet[i].weight];
                        table[i][w] = Math.max(prevValue, newValue);
                    }
                }
            }


            printSolution(inputSet, capacity, table);
        }

        function addSolutionMarkers(solution) {
            for (let i = 0; i < solution.length; i++) {
                let coord = [solution[i].lng, solution[i].lat]
                let feature = new ol.Feature({
                    type: 'place',
                    geometry: new ol.geom.Point(ol.proj.fromLonLat(coord))
                });
                feature.setStyle(styles.icon);
                vectorSource.addFeature(feature);
            }
        }

        function printSolution(inputSet, capacity, table) {
            let solution = [];

            let result = table[inputSet.length - 1][capacity];
            let weight = capacity;

            for (let i = (inputSet.length - 1); i > 0 && result > 0; i--) {
                if (result == table[i - 1][weight]) {
                    continue;
                } else {
                    solution.push(inputSet[i]);

                    result = result - inputSet[i].value;
                    weight = weight - inputSet[i].weight;
                }
            }

            addSolutionMarkers(solution);
        }

        window.onload = () => {
            // let ipt = [
            //     null,
            //     {
            //         value: 1,
            //         weight: 1
            //     },
            //     {
            //         value: 6,
            //         weight: 2
            //     },
            //     {
            //         value: 18,
            //         weight: 5
            //     },
            //     {
            //         value: 22,
            //         weight: 6
            //     },
            //     {
            //         value: 28,
            //         weight: 7
            //     }
            // ];
            // console.log(knapsack(ipt, 11));
            sendGraph();
        }
    </script>
</body>

</html>